{
    "content": "<h2 id=\"writing-building-and-running-chaincode-in-a-development-environment\">Writing, Building, and Running Chaincode in a Development Environment</h2>\n<p>Chaincode developers need a way to test and debug their chaincode without having to set up a complete peer network. By default, when you want to interact with chaincode, you need to first <code>Deploy</code> it using the CLI, REST API, gRPC API, or SDK. Upon receiving this request, the peer node would typically spin up a Docker container with the relevant chaincode. This can make things rather complicated for debugging chaincode under development, because of the turnaround time with the <code>launch chaincode - debug docker container - fix problem - launch chaincode - lather - rinse - repeat</code> cycle. As such, the fabric peer has a <code>--peer-chaincodedev</code> flag that can be passed on start-up to instruct the peer node not to deploy the chaincode as a Docker container.</p>\n<p>The following instructions apply to <em>developing</em> chaincode in Go or Java. They do not apply to running in a production environment. However, if <em>developing</em> chaincode in Java, please see the <a href=\"https://github.com/hyperledger/fabric/blob/master/docs/Setup/JAVAChaincode.md\">Java chaincode setup</a> instructions first, to be sure your environment is properly configured.</p>\n<p><strong>Note:</strong> We have added support for <a href=\"https://github.com/hyperledger/fabric/blob/master/docs/SystemChaincodes/noop.md\">System chaincode</a>.</p>\n<h2 id=\"choices\">Choices</h2>\n<p>Once again, you have the choice of using one of the following approaches:</p>\n<ul>\n<li><a href=\"#option-1-vagrant-development-environment\">Option 1</a> using the <strong>Vagrant</strong> <a href=\"https://github.com/hyperledger/fabric/blob/master/docs/dev-setup/devenv.md\">development environment</a> that is used for developing the fabric itself</li>\n<li><a href=\"#option-2-docker-for-mac-or-windows\">Option 2</a> using Docker for Mac or Windows</li>\n<li><a href=\"#option-3-docker-toolbox\">Option 3</a> using Docker toolbox</li>\n</ul>\n<p>By using options <em>2</em> or <em>3</em>, above, you avoid having to build everything from scratch, and there&rsquo;s no need to keep a clone of the fabric GitHub repos current/up-to-date. Instead, you can simply pull and run the <code>fabric-peer</code> and <code>fabric-membersrvc</code> images directly from DockerHub.</p>\n<p>You will need multiple terminal windows - essentially one for each component. One runs the validating peer; another  runs the chaincode; the third runs the CLI or REST API commands to execute transactions. Finally, when running with security enabled, an additional fourth window is required to run the <strong>Certificate Authority (CA)</strong> server. Detailed instructions are provided in the sections below.</p>\n<h2 id=\"option-1-vagrant-development-environment\">Option 1 Vagrant development environment</h2>\n<h3 id=\"security-setup-optional\">Security Setup (optional)</h3>\n<p>From the <code>devenv</code> subdirectory of your fabric workspace environment, <code>ssh</code> into Vagrant:</p>\n<pre><code>cd $GOPATH/src/github.com/hyperledger/fabric/devenv\nvagrant ssh\n</code></pre>\n\n<p>To set up the local development environment with security enabled, you must first build and run the <strong>Certificate Authority (CA)</strong> server:</p>\n<pre><code>cd $GOPATH/src/github.com/hyperledger/fabric\nmake membersrvc &amp;&amp; membersrvc\n</code></pre>\n\n<p>Running the above commands builds and runs the CA server with the default setup, which is defined in the <a href=\"https://github.com/hyperledger/fabric/blob/master/membersrvc/membersrvc.yaml\">membersrvc.yaml</a> configuration file. The default configuration includes multiple users who are already registered with the CA; these users are listed in the <code>eca.users</code> section of the configuration file. To register additional users with the CA for testing, modify the <code>eca.users</code> section of the <a href=\"https://github.com/hyperledger/fabric/blob/master/membersrvc/membersrvc.yaml\">membersrvc.yaml</a> file to include additional <code>enrollmentID</code> and <code>enrollmentPW</code> pairs. Note the integer that precedes the <code>enrollmentPW</code>. That integer indicates the role of the user, where 1 = client, 2 = non-validating peer, 4 = validating peer, and 8 = auditor.</p>\n<h3 id=\"running-the-validating-peer\">Running the validating peer</h3>\n<p><strong>Note:</strong> To run with security enabled, first modify the <a href=\"https://github.com/hyperledger/fabric/blob/master/peer/core.yaml\">core.yaml</a> configuration file to set the <code>security.enabled</code> value to <code>true</code> before building the peer executable. Alternatively, you can enable security by running the peer with the following environment variable: <code>CORE_SECURITY_ENABLED=true</code>. To enable privacy and confidentiality of transactions (which requires security to also be enabled), modify the <a href=\"https://github.com/hyperledger/fabric/blob/master/peer/core.yaml\">core.yaml</a> configuration file to set the <code>security.privacy</code> value to <code>true</code> as well. Alternatively, you can enable privacy by running the peer with the following environment variable: <code>CORE_SECURITY_PRIVACY=true</code>. If you are enabling security and privacy on the peer process with environment variables, it is important to include these environment variables in the command when executing all subsequent peer operations (e.g. deploy, invoke, or query).</p>\n<p>In a <strong>new</strong> terminal window, from the <code>devenv</code> subdirectory of your fabric workspace environment, <code>ssh</code> into Vagrant:</p>\n<pre><code>cd $GOPATH/src/github.com/hyperledger/fabric/devenv\nvagrant ssh\n</code></pre>\n\n<p>Build and run the peer process to enable security and privacy after setting <code>security.enabled</code> and <code>security.privacy</code> settings to <code>true</code>.</p>\n<pre><code>cd $GOPATH/src/github.com/hyperledger/fabric\nmake peer\npeer node start --peer-chaincodedev\n</code></pre>\n\n<p>Alternatively, rather than tweaking the <code>core.yaml</code> and rebuilding, you can enable security and privacy on the peer with environment variables:</p>\n<pre><code>CORE_SECURITY_ENABLED=true CORE_SECURITY_PRIVACY=true peer node start --peer-chaincodedev\n</code></pre>\n\n<p>Now, you are ready to start <a href=\"#running-the-chaincode\">running the chaincode</a>.</p>\n<h2 id=\"option-2-docker-for-mac-or-windows\">Option 2 Docker for Mac or Windows</h2>\n<p>If you would prefer to simply run the fabric components as built and published by the Hyperledger project on your Mac or Windows laptop/server using the Docker for <a href=\"https://docs.docker.com/engine/installation/mac/\">Mac</a> or <a href=\"https://docs.docker.com/engine/installation/windows/\">Windows</a> platform, following these steps. If using <a href=\"https://docs.docker.com/toolbox/overview/\">Docker Toolbox</a>, please skip to <a href=\"#option-3-docker-toolbox\">Option 3</a>, below.</p>\n<h3 id=\"pull-images-from-dockerhub\">Pull images from DockerHub</h3>\n<p>First, pull the latest images published by the Hyperledger fabric project from DockerHub.</p>\n<pre><code>docker pull hyperledger/fabric-peer:latest\ndocker pull hyperledger/fabric-membersrvc:latest\n</code></pre>\n\n<h3 id=\"running-the-peer-and-ca\">Running the Peer and CA</h3>\n<p>To run the fabric-peer and fabric-membersrvc images, we&rsquo;ll use <a href=\"https://docs.docker.com/compose/\">Docker Compose</a>. It significantly simplifies things. To do that, we&rsquo;ll create a docker-compose.yml file with a description of the two services we&rsquo;ll be running. Here&rsquo;s the docker-compose.yml to launch the two processes:</p>\n<pre><code>membersrvc:\n  image: hyperledger/fabric-membersrvc\n  ports:\n    - &quot;7054:7054&quot;\n  command: membersrvc\nvp0:\n  image: hyperledger/fabric-peer\n  ports:\n    - &quot;7050:7050&quot;\n    - &quot;7051:7051&quot;\n    - &quot;7053:7053&quot;\n  environment:\n    - CORE_PEER_ADDRESSAUTODETECT=true\n    - CORE_VM_ENDPOINT=unix:///var/run/docker.sock\n    - CORE_LOGGING_LEVEL=DEBUG\n    - CORE_PEER_ID=vp0\n    - CORE_PEER_PKI_ECA_PADDR=membersrvc:7054\n    - CORE_PEER_PKI_TCA_PADDR=membersrvc:7054\n    - CORE_PEER_PKI_TLSCA_PADDR=membersrvc:7054\n    - CORE_SECURITY_ENABLED=true\n    - CORE_SECURITY_ENROLLID=test_vp0\n    - CORE_SECURITY_ENROLLSECRET=MwYpmSRjupbT\n  links:\n    - membersrvc\n  command: sh -c &quot;sleep 5; peer node start --peer-chaincodedev&quot;\n</code></pre>\n\n<p>Save that in a directory with the name <code>docker-compose.yml</code>. Then, run <code>docker-compose up</code> to start the two processes.</p>\n<p>Now, you are ready to start <a href=\"#running-the-chaincode\">running the chaincode</a>.</p>\n<h2 id=\"option-3-docker-toolbox\">Option 3 Docker Toolbox</h2>\n<p>If you are using <a href=\"https://docs.docker.com/toolbox/overview/\">Docker Toolbox</a>, please follow these instructions.</p>\n<h3 id=\"pull-images-from-dockerhub_1\">Pull images from DockerHub</h3>\n<p>First, pull the latest images published by the Hyperledger fabric project from DockerHub.</p>\n<pre><code>  docker pull hyperledger/fabric-peer:latest\n  docker pull hyperledger/fabric-membersrvc:latest\n</code></pre>\n\n<h3 id=\"running-the-peer-and-ca_1\">Running the Peer and CA</h3>\n<p>To run the fabric-peer and fabric-membersrvc images, we&rsquo;ll use <a href=\"https://docs.docker.com/compose/\">Docker Compose</a>. It significantly simplifies things. To do that, we&rsquo;ll create a docker-compose.yml file with a description of the two services we&rsquo;ll be running. Here&rsquo;s the docker-compose.yml to launch the two processes:</p>\n<pre><code>membersrvc:\n  image: hyperledger/fabric-membersrvc\n  command: membersrvc\nvp0:\n  image: hyperledger/fabric-peer\n  environment:\n    - CORE_PEER_ADDRESSAUTODETECT=true\n    - CORE_VM_ENDPOINT=http://172.17.0.1:2375\n    - CORE_LOGGING_LEVEL=DEBUG\n    - CORE_PEER_ID=vp0\n    - CORE_PEER_PKI_ECA_PADDR=membersrvc:7054\n    - CORE_PEER_PKI_TCA_PADDR=membersrvc:7054\n    - CORE_PEER_PKI_TLSCA_PADDR=membersrvc:7054\n    - CORE_SECURITY_ENABLED=true\n    - CORE_SECURITY_ENROLLID=test_vp0\n    - CORE_SECURITY_ENROLLSECRET=MwYpmSRjupbT\n  links:\n    - membersrvc\n  command: sh -c &quot;sleep 5; peer node start --peer-chaincodedev&quot;\n</code></pre>\n\n<p>Save that in a directory with the name <code>docker-compose.yml</code>. Then, run <code>docker-compose up</code> to start the two processes.</p>\n<h2 id=\"running-the-chaincode\">Running the chaincode</h2>\n<p>Start a <strong>new</strong> terminal window.</p>\n<h3 id=\"vagrant\">Vagrant</h3>\n<p>If you are using <a href=\"#option-1-vagrant-development-environment\">Option 1</a>, you&rsquo;ll need to <code>ssh</code> to Vagrant. Otherwise, <a href=\"#not-vagrant\">skip</a> this step.</p>\n<pre><code>cd $GOPATH/src/github.com/hyperledger/fabric/devenv\nvagrant ssh\n</code></pre>\n\n<p>Next, we&rsquo;ll build the <strong>chaincode_example02</strong> code, which is provided in the Hyperledger fabric source code repository. If you are using <a href=\"#option-1-vagrant-development-environment\">Option 1</a>, then you can do this from your clone of the fabric repository.</p>\n<pre><code>cd $GOPATH/src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02\ngo build\n</code></pre>\n\n<h3 id=\"not-vagrant\">Not Vagrant</h3>\n<p>If you are using either <a href=\"#option-2-docker-for-mac-or-windows\">Option 2</a> or <a href=\"#option-3-docker-toolbox\">Option 3</a>, you&rsquo;ll need to  download the sample chaincode. The chaincode project must be placed somewhere under the <code>src</code> directory in your local <code>$GOPATH</code> as shown below.</p>\n<pre><code>mkdir -p $GOPATH/src/github.com/chaincode_example02/\ncd $GOPATH/src/github.com/chaincode_example02\ncurl GET https://raw.githubusercontent.com/hyperledger/fabric/master/examples/chaincode/go/chaincode_example02/chaincode_example02.go &gt; chaincode_example02.go\n</code></pre>\n\n<p>Next, you&rsquo;ll need to clone the Hyperledger fabric to your local $GOPATH, so that you can build your chaincode. <strong>Note:</strong> this is a temporary stop-gap until we can provide an independent package for the chaincode shim.</p>\n<pre><code>mkdir -p $GOPATH/src/github.com/hyperledger\ncd $GOPATH/src/github.com/hyperledger\ngit clone http://gerrit.hyperledger.org/r/fabric\n</code></pre>\n\n<p>Now, you should be able to build your chaincode.</p>\n<pre><code>cd $GOPATH/src/github.com/chaincode_example02\ngo build\n</code></pre>\n\n<p>When you are ready to start creating your own Go chaincode, create a new subdirectory under $GOPATH/src. You can copy the <strong>chaincode_example02</strong> file to the new directory and modify it.</p>\n<h3 id=\"starting-and-registering-the-chaincode\">Starting and registering the chaincode</h3>\n<p>Run the following chaincode command to start and register the chaincode with the validating peer:</p>\n<pre><code>CORE_CHAINCODE_ID_NAME=mycc CORE_PEER_ADDRESS=0.0.0.0:7051 ./chaincode_example02\n</code></pre>\n\n<p>The chaincode console will display the message &ldquo;Received REGISTERED, ready for invocations&rdquo;, which indicates that the chaincode is ready to receive requests. Follow the steps below to send a chaincode deploy, invoke or query transaction. If the &ldquo;Received REGISTERED&rdquo; message is not displayed, then an error has occurred during the deployment; revisit the previous steps to resolve the issue.</p>\n<h2 id=\"running-the-cli-or-rest-api\">Running the CLI or REST API</h2>\n<ul>\n<li><a href=\"#chaincode-deploy-via-cli-and-rest\">chaincode deploy via CLI and REST</a></li>\n<li><a href=\"#chaincode-invoke-via-cli-and-rest\">chaincode invoke via CLI and REST</a></li>\n<li><a href=\"#chaincode-query-via-cli-and-rest\">chaincode query via CLI and REST</a></li>\n</ul>\n<p>If you were running with security enabled, see <a href=\"#removing-temporary-files-when-security-is-enabled\">Removing temporary files when security is enabled</a> to learn how to clean up the temporary files.</p>\n<p>See the <a href=\"https://github.com/hyperledger/fabric/blob/master/docs/Setup/logging-control.md\">logging control</a> reference for information on controlling\nlogging output from the <code>peer</code> and chaincodes.</p>\n<h3 id=\"terminal-3-cli-or-rest-api\">Terminal 3 (CLI or REST API)</h3>\n<h4 id=\"note-on-rest-api-port\"><strong>Note on REST API port</strong></h4>\n<p>The default REST interface port is <code>7050</code>. It can be configured in <a href=\"https://github.com/hyperledger/fabric/blob/master/peer/core.yaml\">core.yaml</a> using the <code>rest.address</code> property. If using Vagrant, the REST port mapping is defined in <a href=\"https://github.com/hyperledger/fabric/blob/master/devenv/Vagrantfile\">Vagrantfile</a>.</p>\n<h4 id=\"note-on-security-functionality\"><strong>Note on security functionality</strong></h4>\n<p>Current security implementation assumes that end user authentication takes place at the application layer and is not handled by the fabric. Authentication may be performed through any means considered appropriate for the target application. Upon successful user authentication, the application will perform user registration with the CA exactly once. If registration is attempted a second time for the same user, an error will result. During registration, the application sends a request to the certificate authority to verify the user registration and if successful, the CA responds with the user certificates and keys. The enrollment and transaction certificates received from the CA will be stored locally inside <code>/var/hyperledger/production/crypto/client/</code> directory. This directory resides on a specific peer node which allows the user to transact only through this specific peer while using the stored crypto material. If the end user needs to perform transactions through more then one peer node, the application is responsible for replicating the crypto material to other peer nodes. This is necessary as registering a given user with the CA a second time will fail.</p>\n<p>With security enabled, the CLI commands and REST payloads must be modified to include the <code>enrollmentID</code> of a registered user who is logged in; otherwise an error will result. A registered user can be logged in through the CLI or the REST API by following the instructions below. To log in through the CLI, issue the following commands, where <code>username</code> is one of the <code>enrollmentID</code> values listed in the <code>eca.users</code> section of the <a href=\"https://github.com/hyperledger/fabric/blob/master/membersrvc/membersrvc.yaml\">membersrvc.yaml</a> file.</p>\n<p>From your command line terminal, move to the <code>devenv</code> subdirectory of your workspace environment. Log into a Vagrant terminal by executing the following command:</p>\n<pre><code>    vagrant ssh\n</code></pre>\n\n<p>Register the user though the CLI, substituting for <code>&lt;username&gt;</code> appropriately:</p>\n<pre><code>    cd $GOPATH/src/github.com/hyperledger/fabric/peer\n    peer network login &lt;username&gt;\n</code></pre>\n\n<p>The command will prompt for a password, which must match the <code>enrollmentPW</code> listed for the target user in the <code>eca.users</code> section of the <a href=\"https://github.com/hyperledger/fabric/blob/master/membersrvc/membersrvc.yaml\">membersrvc.yaml</a> file. If the password entered does not match the <code>enrollmentPW</code>, an error will result.</p>\n<p>To log in through the REST API, send a POST request to the <code>/registrar</code> endpoint, containing the <code>enrollmentID</code> and <code>enrollmentPW</code> listed in the <code>eca.users</code> section of the <a href=\"https://github.com/hyperledger/fabric/blob/master/membersrvc/membersrvc.yaml\">membersrvc.yaml</a> file.</p>\n<p><strong>REST Request:</strong></p>\n<pre><code>POST localhost:7050/registrar\n\n{\n  &quot;enrollId&quot;: &quot;jim&quot;,\n  &quot;enrollSecret&quot;: &quot;6avZQLwcUe9b&quot;\n}\n</code></pre>\n\n<p><strong>REST Response:</strong></p>\n<pre><code>200 OK\n{\n    &quot;OK&quot;: &quot;Login successful for user 'jim'.&quot;\n}\n</code></pre>\n\n<h4 id=\"chaincode-deploy-via-cli-and-rest\">chaincode deploy via CLI and REST</h4>\n<p>First, send a chaincode deploy transaction, only once, to the validating peer. The CLI connects to the validating peer using the properties defined in the core.yaml file. <strong>Note:</strong> The deploy transaction typically requires a <code>path</code> parameter to locate, build, and deploy the chaincode. However, because these instructions are specific to local development mode and the chaincode is deployed manually, the <code>name</code> parameter is used instead.</p>\n<pre><code>peer chaincode deploy -n mycc -c '{&quot;Function&quot;:&quot;init&quot;, &quot;Args&quot;: [&quot;a&quot;,&quot;100&quot;, &quot;b&quot;, &quot;200&quot;]}'\n</code></pre>\n\n<p>Alternatively, you can run the chaincode deploy transaction through the REST API.</p>\n<p><strong>REST Request:</strong></p>\n<pre><code>POST host:port/chaincode\n\n{\n  &quot;jsonrpc&quot;: &quot;2.0&quot;,\n  &quot;method&quot;: &quot;deploy&quot;,\n  &quot;params&quot;: {\n    &quot;type&quot;: 1,\n    &quot;chaincodeID&quot;:{\n        &quot;name&quot;: &quot;mycc&quot;\n    },\n    &quot;ctorMsg&quot;: {\n        &quot;function&quot;:&quot;init&quot;,\n        &quot;args&quot;:[&quot;a&quot;, &quot;100&quot;, &quot;b&quot;, &quot;200&quot;]\n    }\n  },\n  &quot;id&quot;: 1\n}\n</code></pre>\n\n<p><strong>REST Response:</strong></p>\n<pre><code>{\n    &quot;jsonrpc&quot;: &quot;2.0&quot;,\n    &quot;result&quot;: {\n        &quot;status&quot;: &quot;OK&quot;,\n        &quot;message&quot;: &quot;mycc&quot;\n    },\n    &quot;id&quot;: 1\n}\n</code></pre>\n\n<p><strong>Note:</strong> When security is enabled, modify the CLI command and the REST API payload to pass the <code>enrollmentID</code> of a logged in user. To log in a registered user through the CLI or the REST API, follow the instructions in the <a href=\"#note-on-security-functionality\">note on security functionality</a>. On the CLI, the <code>enrollmentID</code> is passed with the <code>-u</code> parameter; in the REST API, the <code>enrollmentID</code> is passed with the <code>secureContext</code> element. If you are enabling security and privacy on the peer process with environment variables, it is important to include these environment variables in the command when executing all subsequent peer operations (e.g. deploy, invoke, or query).</p>\n<pre><code>  CORE_SECURITY_ENABLED=true CORE_SECURITY_PRIVACY=true peer chaincode deploy -u jim -n mycc -c '{\"Function\":\"init\", \"Args\": [\"a\",\"100\", \"b\", \"200\"]}'\n</code></pre>\n<p><strong>REST Request:</strong></p>\n<pre><code>POST host:port/chaincode\n\n{\n  &quot;jsonrpc&quot;: &quot;2.0&quot;,\n  &quot;method&quot;: &quot;deploy&quot;,\n  &quot;params&quot;: {\n    &quot;type&quot;: 1,\n    &quot;chaincodeID&quot;:{\n        &quot;name&quot;: &quot;mycc&quot;\n    },\n    &quot;ctorMsg&quot;: {\n        &quot;function&quot;:&quot;init&quot;,\n        &quot;args&quot;:[&quot;a&quot;, &quot;100&quot;, &quot;b&quot;, &quot;200&quot;]\n    },\n    &quot;secureContext&quot;: &quot;jim&quot;\n  },\n  &quot;id&quot;: 1\n}\n</code></pre>\n\n<p>The deploy transaction initializes the chaincode by executing a target initializing function. Though the example shows &ldquo;init&rdquo;, the name could be arbitrarily chosen by the chaincode developer. You should see the following output in the chaincode window:</p>\n<pre><code>    2015/11/15 15:19:31 Received INIT(uuid:005dea42-d57f-4983-803e-3232e551bf61), initializing chaincode\n    Aval = 100, Bval = 200\n</code></pre>\n\n<h4 id=\"chaincode-invoke-via-cli-and-rest\">Chaincode invoke via CLI and REST</h4>\n<p>Run the chaincode invoking transaction on the CLI as many times as desired. The <code>-n</code> argument should match the value provided in the chaincode window (started in Vagrant terminal 2):</p>\n<pre><code>    peer chaincode invoke -l golang -n mycc -c '{&quot;Function&quot;: &quot;invoke&quot;, &quot;Args&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;10&quot;]}'\n</code></pre>\n\n<p>Alternatively, run the chaincode invoking transaction through the REST API.</p>\n<p><strong>REST Request:</strong></p>\n<pre><code>POST host:port/chaincode\n\n{\n  &quot;jsonrpc&quot;: &quot;2.0&quot;,\n  &quot;method&quot;: &quot;invoke&quot;,\n  &quot;params&quot;: {\n      &quot;type&quot;: 1,\n      &quot;chaincodeID&quot;:{\n          &quot;name&quot;:&quot;mycc&quot;\n      },\n      &quot;ctorMsg&quot;: {\n         &quot;function&quot;:&quot;invoke&quot;,\n         &quot;args&quot;:[&quot;a&quot;, &quot;b&quot;, &quot;10&quot;]\n      }\n  },\n  &quot;id&quot;: 3\n}\n</code></pre>\n\n<p><strong>REST Response:</strong></p>\n<pre><code>{\n    &quot;jsonrpc&quot;: &quot;2.0&quot;,\n    &quot;result&quot;: {\n        &quot;status&quot;: &quot;OK&quot;,\n        &quot;message&quot;: &quot;5a4540e5-902b-422d-a6ab-e70ab36a2e6d&quot;\n    },\n    &quot;id&quot;: 3\n}\n</code></pre>\n\n<p><strong>Note:</strong> When security is enabled, modify the CLI command and REST API payload to pass the <code>enrollmentID</code> of a logged in user. To log in a registered user through the CLI or the REST API, follow the instructions in the <a href=\"#note-on-security-functionality\">note on security functionality</a>. On the CLI, the <code>enrollmentID</code> is passed with the <code>-u</code> parameter; in the REST API, the <code>enrollmentID</code> is passed with the <code>secureContext</code> element. If you are enabling security and privacy on the peer process with environment variables, it is important to include these environment variables in the command when executing all subsequent peer operations (e.g. deploy, invoke, or query).</p>\n<pre><code>  CORE_SECURITY_ENABLED=true CORE_SECURITY_PRIVACY=true peer chaincode invoke -u jim -l golang -n mycc -c '{\"Function\": \"invoke\", \"Args\": [\"a\", \"b\", \"10\"]}'\n</code></pre>\n<p><strong>REST Request:</strong></p>\n<pre><code>POST host:port/chaincode\n\n{\n  &quot;jsonrpc&quot;: &quot;2.0&quot;,\n  &quot;method&quot;: &quot;invoke&quot;,\n  &quot;params&quot;: {\n      &quot;type&quot;: 1,\n      &quot;chaincodeID&quot;:{\n          &quot;name&quot;:&quot;mycc&quot;\n      },\n      &quot;ctorMsg&quot;: {\n         &quot;function&quot;:&quot;invoke&quot;,\n         &quot;args&quot;:[&quot;a&quot;, &quot;b&quot;, &quot;10&quot;]\n      },\n      &quot;secureContext&quot;: &quot;jim&quot;\n  },\n  &quot;id&quot;: 3\n}\n</code></pre>\n\n<p>The invoking transaction runs the specified chaincode function name &ldquo;invoke&rdquo; with the arguments. This transaction transfers 10 units from A to B. You should see the following output in the chaincode window:</p>\n<pre><code>    2015/11/15 15:39:11 Received RESPONSE. Payload 200, Uuid 075d72a4-4d1f-4a1d-a735-4f6f60d597a9\n    Aval = 90, Bval = 210\n</code></pre>\n\n<h4 id=\"chaincode-query-via-cli-and-rest\">Chaincode query via CLI and REST</h4>\n<p>Run a query on the chaincode to retrieve the desired values. The <code>-n</code> argument should match the value provided in the chaincode window (started in Vagrant terminal 2):</p>\n<pre><code>    peer chaincode query -l golang -n mycc -c '{&quot;Function&quot;: &quot;query&quot;, &quot;Args&quot;: [&quot;b&quot;]}'\n</code></pre>\n\n<p>The response should be similar to the following:</p>\n<pre><code>    {&quot;Name&quot;:&quot;b&quot;,&quot;Amount&quot;:&quot;210&quot;}\n</code></pre>\n\n<p>If a name other than &ldquo;a&rdquo; or &ldquo;b&rdquo; is provided in a query sent to <code>chaincode_example02</code>, you should see an error response similar to the following:</p>\n<pre><code>    {&quot;Error&quot;:&quot;Nil amount for c&quot;}\n</code></pre>\n\n<p>Alternatively, run the chaincode query transaction through the REST API.</p>\n<p><strong>REST Request:</strong></p>\n<pre><code>POST host:port/chaincode\n\n{\n  &quot;jsonrpc&quot;: &quot;2.0&quot;,\n  &quot;method&quot;: &quot;query&quot;,\n  &quot;params&quot;: {\n      &quot;type&quot;: 1,\n      &quot;chaincodeID&quot;:{\n          &quot;name&quot;:&quot;mycc&quot;\n      },\n      &quot;ctorMsg&quot;: {\n         &quot;function&quot;:&quot;query&quot;,\n         &quot;args&quot;:[&quot;a&quot;]\n      }\n  },\n  &quot;id&quot;: 5\n}\n</code></pre>\n\n<p><strong>REST Response:</strong></p>\n<pre><code>{\n    &quot;jsonrpc&quot;: &quot;2.0&quot;,\n    &quot;result&quot;: {\n        &quot;status&quot;: &quot;OK&quot;,\n        &quot;message&quot;: &quot;90&quot;\n    },\n    &quot;id&quot;: 5\n}\n</code></pre>\n\n<p><strong>Note:</strong> When security is enabled, modify the CLI command and REST API payload to pass the <code>enrollmentID</code> of a logged in user. To log in a registered user through the CLI or the REST API, follow the instructions in the <a href=\"#note-on-security-functionality\">note on security functionality</a>. On the CLI, the <code>enrollmentID</code> is passed with the <code>-u</code> parameter; in the REST API, the <code>enrollmentID</code> is passed with the <code>secureContext</code> element. If you are enabling security and privacy on the peer process with environment variables, it is important to include these environment variables in the command when executing all subsequent peer operations (e.g. deploy, invoke, or query).</p>\n<pre><code>      CORE_SECURITY_ENABLED=true CORE_SECURITY_PRIVACY=true peer chaincode query -u jim -l golang -n mycc -c '{&quot;Function&quot;: &quot;query&quot;, &quot;Args&quot;: [&quot;b&quot;]}'\n</code></pre>\n\n<p><strong>REST Request:</strong></p>\n<pre><code>POST host:port/chaincode\n\n{\n  &quot;jsonrpc&quot;: &quot;2.0&quot;,\n  &quot;method&quot;: &quot;query&quot;,\n  &quot;params&quot;: {\n      &quot;type&quot;: 1,\n      &quot;chaincodeID&quot;:{\n          &quot;name&quot;:&quot;mycc&quot;\n      },\n      &quot;ctorMsg&quot;: {\n         &quot;function&quot;:&quot;query&quot;,\n         &quot;args&quot;:[&quot;a&quot;]\n      },\n      &quot;secureContext&quot;: &quot;jim&quot;\n  },\n  &quot;id&quot;: 5\n}\n</code></pre>\n\n<h4 id=\"removing-temporary-files-when-security-is-enabled\">Removing temporary files when security is enabled</h4>\n<p><strong>Note:</strong> this step applies <strong>ONLY</strong> if you were using Option 1 above. For Option 2 or 3, the cleanup is handled by Docker.</p>\n<p>After the completion of a chaincode test with security enabled, remove the temporary files that were created by the CA server process. To remove the client enrollment certificate, enrollment key, transaction certificate chain, etc., run the following commands. Note, that you must run these commands if you want to register a user who has already been registered previously.</p>\n<p>From your command line terminal, <code>ssh</code> into Vagrant:</p>\n<pre><code>cd $GOPATH/src/github.com/hyperledger/fabric/devenv\nvagrant ssh\n</code></pre>\n\n<p>And then run:</p>\n<pre><code>rm -rf /var/hyperledger/production\n</code></pre>",
    "language": "en",
    "url": "/Setup/Chaincode-setup/",
    "title": "Chaincode or Application Developer Setup"
}