{
    "content": "<h1 id=\"hyperledger-fabric-application-access-control-lists\">Hyperledger Fabric - Application Access Control Lists</h1>\n<h2 id=\"overview\">Overview</h2>\n<p>We consider the following entities:</p>\n<ol>\n<li><em>HelloWorld</em>: is a chaincode that contains a single function called <em>hello</em>;</li>\n<li><em>Alice</em>: is the <em>HelloWorld</em> deployer;</li>\n<li><em>Bob</em>: is the <em>HelloWorld</em>&lsquo;s functions invoker.</li>\n</ol>\n<p>Alice wants to ensure that only Bob can invoke the function <em>hello</em>.</p>\n<h2 id=\"fabric-support\">Fabric Support</h2>\n<p>To allow Alice to specify her own access control lists and Bob to gain access, the fabric layer gives access to following capabilities:</p>\n<ol>\n<li>Alice and Bob can sign and verify any message with specific transaction certificates or enrollment certificate they own;</li>\n<li>The fabric allows to <em>name</em> each transaction by means of a unique <em>binding</em> to be used to bind application data\nto the underlying transaction transporting it;</li>\n<li>Extended transaction format.</li>\n</ol>\n<p>The fabric layer exposes the following interfaces and functions to allow the application layer to define its own ACLS.</p>\n<h3 id=\"certificate-handler\">Certificate Handler</h3>\n<p>The following interface allows to sign and verify any message using signing key-pair underlying the associated certificate.\nThe certificate can be a TCert or an ECert.</p>\n<pre><code>// CertificateHandler exposes methods to deal with an ECert/TCert\ntype CertificateHandler interface {\n\n    // GetCertificate returns the certificate's DER\n    GetCertificate() []byte\n\n    // Sign signs msg using the signing key corresponding to the certificate\n    Sign(msg []byte) ([]byte, error)\n\n    // Verify verifies msg using the verifying key corresponding to the certificate\n    Verify(signature []byte, msg []byte) error\n\n    // GetTransactionHandler returns a new transaction handler relative to this certificate\n    GetTransactionHandler() (TransactionHandler, error)\n}\n</code></pre>\n\n<h3 id=\"transaction-handler\">Transaction Handler</h3>\n<p>The following interface allows to create transactions and give access to the underlying <em>binding</em> that can be leveraged to link\napplication data to the underlying transaction.</p>\n<pre><code>// TransactionHandler represents a single transaction that can be named by the output of the GetBinding method.\n// This transaction is linked to a single Certificate (TCert or ECert).\ntype TransactionHandler interface {\n\n    // GetCertificateHandler returns the certificate handler relative to the certificate mapped to this transaction\n    GetCertificateHandler() (CertificateHandler, error)\n\n    // GetBinding returns a binding to the underlying transaction\n    GetBinding() ([]byte, error)\n\n    // NewChaincodeDeployTransaction is used to deploy chaincode\n    NewChaincodeDeployTransaction(chaincodeDeploymentSpec *obc.ChaincodeDeploymentSpec, uuid string) (*obc.Transaction, error)\n\n    // NewChaincodeExecute is used to execute chaincode's functions\n    NewChaincodeExecute(chaincodeInvocation *obc.ChaincodeInvocationSpec, uuid string) (*obc.Transaction, error)\n\n    // NewChaincodeQuery is used to query chaincode's functions\n    NewChaincodeQuery(chaincodeInvocation *obc.ChaincodeInvocationSpec, uuid string) (*obc.Transaction, error)\n}\n</code></pre>\n\n<h3 id=\"client\">Client</h3>\n<p>The following interface offers a mean to get instances of the previous interfaces.</p>\n<pre><code>type Client interface {\n\n    ...\n\n    // GetEnrollmentCertHandler returns a CertificateHandler whose certificate is the enrollment certificate\n    GetEnrollmentCertificateHandler() (CertificateHandler, error)\n\n    // GetTCertHandlerNext returns a CertificateHandler whose certificate is the next available TCert\n    GetTCertificateHandlerNext() (CertificateHandler, error)\n\n    // GetTCertHandlerFromDER returns a CertificateHandler whose certificate is the one passed\n    GetTCertificateHandlerFromDER(der []byte) (CertificateHandler, error)\n\n}\n</code></pre>\n\n<h3 id=\"transaction-format\">Transaction Format</h3>\n<p>To support application-level ACLs, the fabric&rsquo;s transaction and chaincode specification format have an additional field to store application-specific metadata.\nThe content of this field is decided by the application. The fabric layer treats it as an unstructured stream of bytes.</p>\n<pre><code>\nmessage ChaincodeSpec {\n\n    ...\n\n    ConfidentialityLevel confidentialityLevel;\n    bytes metadata;\n\n    ...\n}\n\n\nmessage Transaction {\n    ...\n\n    bytes payload;\n    bytes metadata;\n\n    ...\n}\n</code></pre>\n\n<p>Another way to achieve this is to have the payload contain the metadata itself.</p>\n<h3 id=\"validators\">Validators</h3>\n<p>To assist chaincode execution, the validators provide the chaincode additional information, such as the metadata and the binding.</p>\n<h2 id=\"application-level-access-control\">Application-level access control</h2>\n<h3 id=\"deploy-transaction\">Deploy Transaction</h3>\n<p>Alice has full control over the deployment transaction&rsquo;s metadata.\nIn particular, the metadata can be used to store a list of ACLs (one per function), or a list of roles.\nTo define each of these lists/roles, Alice can use any TCerts/ECerts of the users who have been\ngranted that (access control) privilege or have been assigned that role. The latter is done offline.</p>\n<p>Now, Alice requires that in order to invoke the <em>hello</em> function, a certain message <em>M</em> has to be authenticated by an authorized invoker (Bob, in our case).\nWe distinguish the following two cases:</p>\n<ol>\n<li><em>M</em> is one of the chaincode&rsquo;s function arguments;</li>\n<li><em>M</em> is the invocation message itself, i.e., function-name, arguments.</li>\n</ol>\n<h3 id=\"execute-transaction\">Execute Transaction</h3>\n<p>To invoke <em>hello</em>, Bob needs to sign <em>M</em> using the TCert/ECert Alice has used to name him in the deployment transaction&rsquo;s metadata.\nLet&rsquo;s call this certificate CertBob. At this point Bob does the following:   </p>\n<ol>\n<li>Bob obtains a <em>CertificateHandler</em> for CertBob, <em>cHandlerBob</em>;</li>\n<li>Bob obtains a new <em>TransactionHandler</em> to issue the execute transaction, <em>txHandler</em> relative to his next available TCert or his ECert;</li>\n<li>Bob obtains <em>txHandler</em>&lsquo;s <em>binding</em> by invoking <em>txHandler.getBinding()</em>;</li>\n<li>Bob signs <em>&lsquo;M || txBinding&rsquo;</em> by invoking <em>cHandlerBob.Sign(&lsquo;M || txBinding&rsquo;)</em>, let <em>signature</em> be the output of the signing function;</li>\n<li>Bob issues a new execute transaction by invoking, <em>txHandler.NewChaincodeExecute(&hellip;)</em>. Now, <em>signature</em> can be included\n  in the transaction as one of the argument to be passed to the function or as transaction metadata.</li>\n</ol>\n<h3 id=\"chaincode-execution\">Chaincode Execution</h3>\n<p>The validators, who receive the execute transaction issued by Bob, will provide to <em>hello</em> the following information:</p>\n<ol>\n<li>The <em>binding</em> of the execute transaction;</li>\n<li>The <em>metadata</em> of the execute transaction;</li>\n<li>The <em>metadata</em> of the deploy transaction.</li>\n</ol>\n<p>Then, <em>hello</em> is responsible for checking that <em>signature</em> is indeed a valid signature issued by Bob.</p>",
    "language": "en",
    "url": "/tech/application-ACL/",
    "title": "Application ACL"
}