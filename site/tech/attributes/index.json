{
    "content": "<h1 id=\"attributes-support\">Attributes support</h1>\n<p>To support attributes the user has to pass them during TCert creation, these attributes can be used  during transaction deployment, execution or query for Attribute Based Access Control (ABAC) to determine whether the user can or cannot execute a specific chaincode  or used attributes&rsquo; values for other purposes. A mechanism to validate the ownership of attributes is required in order to prove if the attributes passed by the user are correct. The Attribute Certificate Authority (ACA) has the responsibility of validate attributes and to return an Attribute Certificate (ACert) with the valid attribute values.\nAttributes values are encrypted using the keys defined below (section Attributes keys).</p>\n<h2 id=\"attribute-keys\">Attribute Keys</h2>\n<p>The attributes are encrypted using a key derived from a hierarchy called PreKey tree. This approach consists in deriving keys from a parent key, allowing the parent key owner, get access to derived keys. This way keys used to encrypt attributes are different among attributes and TCerts avoiding linkability while allowing an authorized auditor who owns a parent key to derive the keys in the lower levels.</p>\n<h3 id=\"example-of-prekey-tree\">Example of prekey tree</h3>\n<pre><code>Pre3K_BI\n        |_Pre2K_B = HMAC(Pre3K_BI, \u201cbanks\u201d)\n        |   |_Pre1K_BankA = HMAC(Pre2K_B, \u201cBank A\u201d)\n        |   |   |_Pre0K_BankA = HMAC(Pre1K_BankA, TCertID)\n        |   |       |_PositionKey_BankA_TIdx = HMAC(Pre0K_BankA, \"position\")\n        |   |       |_CompanyKey_BankA_TIdx = HMAC(Pre0K_BankA, \"company\")\n        |   |\n        |   |_Pre1K_BankB = HMAC(Pre2K_B, \u201cBanKB\u201d)\n        |       |_Pre0K_BankB = HMAC(Pre1K_BankB, TCertID)\n        |            |_PositionKey_BankB_TIdx = HMAC(Pre0K_BankB, \"position\")\n        |            |_CompanyKey_BankB_TIdx = HMAC(Pre0K_BankB, \"company\")\n        |\n        |_Pre2K_I = HMAC(Pre3K_BI, \"institutions\")\n            |_Pre1K_InstitutionA= HMAC(Pre2K_I, \"Institution A\u201d)\n               |_Pre0K_InstitutionA = HMAC(_Pre1K_InstitutionA, TCertID)\n                    |_PositionKey_InstA_TIdx = HMAC(Pre0K_InstitutionA, \"position\")\n                    |_CompanyKey_InstA_TIdx = HMAC(Pre0K_InstitutionA, \"company\")\n</code></pre>\n<ul>\n<li>Pre3K_BI: is available to TCA and auditors for banks and institutions.</li>\n<li>Pre2K_B: is available to auditors for banks</li>\n<li>Pre1K_BankA: is available to auditors for Bank A.</li>\n<li>Pre1K_BankB: is available to auditors for Bank B.</li>\n<li>Pre2K_I: is available to auditors for institutions.</li>\n<li>Pre1K_InstitutionA: is available to auditors for Institution A.</li>\n</ul>\n<p>Each TCert has a different PreK0 (for example Pre0K_BankA) and each TCert attribute has a different attribute key (for example PositionKey_BankA_TIdx).</p>\n<h2 id=\"attribute-certificate-authority\">Attribute Certificate Authority</h2>\n<p>Attribute Certificate Authority (ACA) has the responsibility of certify the ownership of the attributes. ACA has a database to hold attributes for each user and affiliation.</p>\n<ol>\n<li>id: The id passed by the user during enrollment</li>\n<li>affiliation: The entity which the user is affiliated to</li>\n<li>attributeName: The name used to look for the attribute, e.g. &lsquo;position&rsquo;</li>\n<li>attributeValue: The value of the attribute, e.g. &lsquo;software engineer&rsquo;</li>\n<li>validFrom: The start of the attribute&rsquo;s validity period</li>\n<li>validTo: The end of the attribute&rsquo;s validity period</li>\n</ol>\n<h3 id=\"grpc-aca-api\">gRPC ACA API</h3>\n<ol>\n<li>FetchAttributes</li>\n</ol>\n<pre><code>    rpc FetchAttributes(ACAFetchAttrReq) returns (ACAFetchAttrResp);\n\n    message ACAFetchAttrReq {\n        google.protobuf.Timestamp ts = 1;\n        Cert eCert = 2;                  // ECert of involved user.\n        Signature signature = 3;         // Signed using the ECA private key.\n    }\n\n    message ACAFetchAttrResp {\n        enum StatusCode {\n            SUCCESS = 000;\n            FAILURE = 100;\n        }\n        StatusCode status = 1;\n    }\n</code></pre>\n\n<ol>\n<li>RequestAttributes</li>\n</ol>\n<pre><code>    rpc RequestAttributes(ACAAttrReq) returns (ACAAttrResp);\n\n    message ACAAttrReq {\n        google.protobuf.Timestamp ts = 1;\n        Identity id = 2;\n        Cert eCert = 3;                                // ECert of involved user.\n        repeated TCertAttributeHash attributes = 4;    // Pairs attribute-key, attribute-value-hash\n        Signature signature = 5;                       // Signed using the TCA private key.\n    }\n\n    message ACAAttrResp {\n        enum StatusCode {\n            FULL_SUCCESSFUL     = 000;\n            PARTIAL_SUCCESSFUL  = 001;\n            NO_ATTRIBUTES_FOUND = 010;\n            FAILURE             = 100;\n        }\n        StatusCode status = 1;\n        Cert cert = 2;                  // ACert with the owned attributes.\n        Signature signature = 3;        // Signed using the ACA private key.\n    }\n</code></pre>\n\n<ol>\n<li>RefreshAttributes</li>\n</ol>\n<pre><code>    rpc RefreshAttributes(ACARefreshReq) returns (ACARefreshResp);\n\n    message ACARefreshAttrReq {\n        google.protobuf.Timestamp ts = 1;\n        Cert eCert = 2;                              // ECert of the involved user.\n        Signature signature = 3;                     // Signed using enrollPrivKey\n    }\n\n    message ACARefreshAttrResp {\n        enum StatusCode {\n            SUCCESS = 000;\n            FAILURE = 100;\n        }\n        StatusCode status = 1;\n    }\n</code></pre>\n\n<h2 id=\"flow\">FLOW</h2>\n<p><img alt=\"ACA flow\" src=\"../../images/attributes_flow.png\" /></p>\n<h3 id=\"during-enrollment\">During enrollment</h3>\n<ol>\n<li>The user requests an Enrollment Certificate (ECert) to ECA</li>\n<li>ECA creates the ECert and responds to the user with it.</li>\n<li>ECA issues a fetch request under TLS to the ACA passing the newly generated ECert as a parameter. This request is signed with the ECA&rsquo;s private key.</li>\n<li>The request triggers ACA asynchronous mechanism that fetches attributes&rsquo; values from external sources and populates the attributes database (in the current implementation attributes are loaded from an internal configuration file).</li>\n</ol>\n<h3 id=\"during-tcert-generation\">During TCert generation</h3>\n<ol>\n<li>When the user needs TCerts to create a new transaction it requests a batch of TCerts to the TCA, and provides the following:</li>\n<li>The batch size (i.e. how many TCerts the user is expecting)</li>\n<li>Its ECert</li>\n<li>A list of attributes (e.g. Company, Position)</li>\n<li>Under TLS TCA sends a RequestAttributes() to ACA to verify if the user is in possession of those attributes. This request is signed with TCA&rsquo;s private key and it contains:</li>\n<li>User&rsquo;s ECert</li>\n<li>A list of attribute names &ldquo;company, position, &hellip;&rdquo;</li>\n<li>The ACA performs a query to the internal attributes database and there are three possible scenarios***:\n     a. The user does not have any of the specified attributes \u2013 An error is returned.\n     b. The user has all the specified attributes \u2013 An X.509 certificate (ACert) with all the specified attributes and the ECert public key is returned.\n     c. The user has a subset of the requested attributes \u2013 An X.509 certificate (ACert) with just the subset of the specified attributes and the ECert public key is returned.</li>\n<li>The TCA checks the validity period of the ACert&rsquo;s attributes and updates the list by eliminating those that are expired. Then for scenarios b and c from the previous item it checks how many (and which ones) of the attributes the user will actually receive inside each TCert. This information needs to be returned to the user in order to decide whether the TCerts are useful or if further actions needs to be performed (i.e. issue a RefreshAttributes command and request a new batch, throw an error or make use of the TCerts as they are).</li>\n<li>The TCA could have other criteria to update the valid list of attributes.</li>\n<li>The TCA creates the batch of TCerts. Each TCert contains the valid attributes encrypted with keys derived from the Prekey tree (each key is unique per attribute, per TCert and per user).</li>\n<li>The TCA returns the batch of TCerts to the user along with a root key (Prek0) from which each attribute encryption key was derived. There is a Prek0 per TCert. All the TCerts in the batch have the same attributes and the validity period of the TCerts is the same for the entire batch.</li>\n</ol>\n<p>*** <em>In the current implementation an attributes refresh is executed automatically before this step, but once the refresh service is implemented the user will have the responsibility of keeping his/her attributes updated by invoking this method.</em></p>\n<h3 id=\"assumptions\">Assumptions</h3>\n<ol>\n<li>An Attribute Certificate Authority (ACA) has been incorporated to the Membership Services internally to provide a trusted source for attribute values.</li>\n<li>In the current implementation attributes are loaded from a configuration file (membersrvc.yml).</li>\n<li>Refresh attributes service is not implemented yet, instead, attributes are refreshed in each RequestAttribute invocation.</li>\n</ol>",
    "language": "en",
    "url": "/tech/attributes/",
    "title": "Attributes"
}